# Implementation of strncpy for 32-bit integer arrays
# Parameters:
#   %edi: dest (destination array)
#   %esi: src (source array)
#   %edx: n (maximum number of elements to copy)
# Returns:
#   %eax: pointer to dest

.pos 0
init:   irmovl Stack, %esp    # Initialize stack pointer
        irmovl Stack, %ebp    # Initialize frame pointer
        call main             # Call main function
        halt

# Test arrays
array1: .long 1
        .long 2
        .long 3
        .long 0
        .long 5
        .long 6    # Array with sentinel before n

array2: .long 1
        .long 2
        .long 3
        .long 4
        .long 5
        .long 6    # Array without sentinel before n

dest:   .long 0
        .long 0
        .long 0
        .long 0
        .long 0
        .long 0    # Destination array

main:
        # Test case 1: Sentinel found before n
        irmovl array1, %esi   # Source array
        irmovl dest, %edi     # Destination array
        irmovl $4, %edx       # n = 4
        call strncpy          # Call strncpy
        # Result should be: 1, 2, 3, 0, 0, 0

        # Test case 2: Sentinel not found before n
        irmovl array2, %esi   # Source array
        irmovl dest, %edi     # Destination array
        irmovl $4, %edx       # n = 4
        call strncpy          # Call strncpy
        # Result should be: 1, 2, 3, 4, 0, 0

        ret

# strncpy implementation
strncpy:
        pushl %ebx           # Save %ebx
        irmovl $0, %eax      # Initialize counter
        jmp test

loop:
        mrmovl (%esi), %ebx  # Load source word
        rmmovl %ebx, (%edi)  # Store in destination
        decl %edx            # Decrement n
        je done              # If n == 0, we're done
        irmovl $0, %ebx      # Compare with 0
        subl %ebx, %ebx      # Set condition codes
        je done              # If source word is 0, we're done
        incl %esi            # Increment source pointer
        incl %edi            # Increment destination pointer
        incl %eax            # Increment counter

test:
        irmovl $0, %ebx      # Compare n with 0
        subl %ebx, %edx      # Set condition codes
        jg loop              # If n > 0, continue loop

done:
        irmovl $0, %ebx      # Store 0 at end of destination
        rmmovl %ebx, (%edi)
        popl %ebx            # Restore %ebx
        ret

.pos 0x100
Stack:                          # Stack area 